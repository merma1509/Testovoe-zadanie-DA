# Анализ сложности алгоритмов

## 1. Изоморфность строк (isomorphic.py)

### Алгоритм
Использует два словаря для отслеживания соответствий между символами строк.

### Временная сложность: O(n)
- Проходим по строкам один раз
- Каждая операция со словарем: O(1) в среднем
- Итого: O(n), где n - длина строк

### Пространственная сложность: O(k)
- Два словаря хранят соответствия
- k - количество уникальных символов (k ≤ n)
- В худшем случае: O(n)

### Оптимизации
- Ранний выход при разной длине строк
- Использование хеш-таблиц для быстрого доступа

---

## 2. Поиск отсутствующего числа (missing_number.py)

### Основной алгоритм (арифметический метод)
Использует формулу суммы первых n натуральных чисел.

### Временная сложность: O(n)
- Один проход для суммирования массива
- Формула вычисляется за O(1)

### Пространственная сложность: O(1)
- Используем только несколько переменных
- Никаких дополнительных структур данных

### Альтернативный алгоритм (XOR метод)
- Временная сложность: O(n)
- Пространственная сложность: O(1)
- Преимущество: нет риска переполнения для больших чисел

---

## 3. Факторизация (prime_factors.py)

### Основной алгоритм (пробное деление)
Делит число на простые множители до √n.

### Временная сложность: O(√n)
- Внешний цикл до √n
- Внутренний цикл while для каждого делителя
- В худшем случае (когда n - простое число): O(√n)

### Пространственная сложность: O(log n)
- Максимальное количество множителей для числа n
- log₂n множителей (все двойки) - худший случай

### Оптимизации
1. **Отдельная обработка двойки**: сокращает количество итераций вдвое
2. **Решето Эратосфена**: для малых чисел (< 1000) эффективнее
3. **Ранний выход**: когда divisor² > remaining

### Сравнение подходов
- Базовый: O(√n) время, O(log n) память
- С решетом: O(√n) время, O(√n) память для решета
- Для больших чисел (> 10⁶) нужны более продвинутые алгоритмы

---

## Общие выводы

### Выбор алгоритмов
1. **Изоморфность**: оптимальное решение с хеш-таблицами
2. **Отсутствующее число**: арифметический метод наиболее эффективен
3. **Факторизация**: базовый алгоритм достаточен для типичных случаев

### Альтернативные подходы
- Изоморфность: можно использовать массивы для ASCII символов
- Отсутствующее число: метод XOR для избежания переполнения
- Факторизация: алгоритмы Полларда для очень больших чисел

### Практические соображения
- Все алгоритмы легко читаемы и поддерживаемы
- Сложность соответствует требованиям задач
- Код готов к использованию в production

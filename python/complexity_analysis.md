# Анализ сложности алгоритмов

## 1. Изоморфность строк (isomorphic.py)

### Алгоритм

Использует два словаря для отслеживания соответствий между символами строк.

### Временная сложность: $O(n)$

- Проходим по строкам один раз
- Каждая операция со словарем: $O(1)$ в среднем
- Итого: $O(n)$, где n - длина строк

### Пространственная сложность: $O(k)$

- Два словаря хранят соответствия
- k - количество уникальных символов (k ≤ n)
- В худшем случае: $O(n)$

### Оптимизации

- Ранний выход при разной длине строк
- Использование хеш-таблиц для быстрого доступа

---

## 2. Поиск отсутствующего числа (missing_number.py)

### Основной алгоритм (арифметический метод)

Использует формулу суммы первых n натуральных чисел.

### Временная сложность: $O(n)$

- Один проход для суммирования массива
- Формула вычисляется за $O(1)$

### Пространственная сложность: $O(1)$

- Используем только несколько переменных
- Никаких дополнительных структур данных

### Альтернативный алгоритм (XOR метод)

- Временная сложность: $O(n)$
- Пространственная сложность: $O(1)$
- Преимущество: нет риска переполнения для больших чисел

---

## 3. Факторизация (prime_factors.py)

### Основной алгоритм (пробное деление)

Делит число на простые множители до $\sqrt{n}$.

### Временная сложность: $O(\sqrt{n})$

- Внешний цикл до $\sqrt{n}$
- Внутренний цикл while для каждого делителя
- В худшем случае (когда n - простое число): $O(\sqrt{n})$

### Пространственная сложность: $O(\log n)$

- Максимальное количество множителей для числа n
- $\log_2 n$ множителей (все двойки) - худший случай

### Оптимизации

- **Отдельная обработка двойки**: сокращает количество итераций вдвое
- **Решето Эратосфена**: для малых чисел (< 1000) эффективнее
- **Ранний выход**: когда divisor² > remaining

### Сравнение подходов

- Базовый: $O(\sqrt{n})$ время, $O(\log n)$ память
- С решетом: $O(\sqrt{n})$ время, $O(\sqrt{n})$ память для решета
- Для больших чисел (> 10⁶) нужны более продвинутые алгоритмы

---

## Общие выводы

### Выбор алгоритмов

1. **Изоморфность**: оптимальное решение с хеш-таблицами
2. **Отсутствующее число**: арифметический метод наиболее эффективен
3. **Факторизация**: базовый алгоритм достаточен для типичных случаев

### Альтернативные подходы

- Изоморфность: можно использовать массивы для ASCII символов
- Отсутствующее число: метод XOR для избежания переполнения
- Факторизация: алгоритмы Полларда для очень больших чисел

### Практические соображения

- Все алгоритмы легко читаемы и поддерживаемы
- Сложность соответствует требованиям задач
- Код готов к использованию в production
